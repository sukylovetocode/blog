(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{368:function(e,t,a){"use strict";a.r(t);var r=a(44),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"❗-什么是-webpack-的-hmr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#❗-什么是-webpack-的-hmr"}},[e._v("#")]),e._v(" ❗ 什么是 webpack 的 HMR")]),e._v(" "),a("p",[e._v("场景： 修改代码以后保存页面会自动刷新，我们输入的信息也能够保存下来 不会发生整体刷新页面的情况")]),e._v(" "),a("p",[e._v("使用： 现在在 webpack-dev-server 中会本身带有 HMR 因此我们只要使用 webpack-dev-server 就相当于使用了 HMR")]),e._v(" "),a("p",[e._v("技术：")]),e._v(" "),a("ul",[a("li",[e._v("express")]),e._v(" "),a("li",[e._v("socket.io")]),e._v(" "),a("li",[e._v("ajax")])]),e._v(" "),a("p",[e._v("原理：搞了一天 本来想搞个 demo 的，最后还是失败了 问题出在我们自己打包的东西没有生成热更新所需的 hot.update.json 和 hot.update.js 文件 这个应该需要 webpack 去配合一下 但是大概对流程已经算是了解 就不再纠结这个事情了")]),e._v(" "),a("p",[a("img",{attrs:{src:"/images/1592483617-5d72057db4a8c.jpg",alt:"2021-04-29%2059acab6017aa4df192ad0099258cba8b/1592483617-5d72057db4a8c.jpg"}})]),e._v(" "),a("ol",[a("li",[e._v("webpack-dev-server 中包含三个子服务器，一个是控制页面输出的 http 服务器、一个是监听我们文件中是否有改变的 webpack watch 服务器还有一个是与前端交互的 socket 服务器")]),e._v(" "),a("li",[e._v("一个更新的流程: 修改了源文件 → webpack 监听到变化，重新编译成含有更新内容的 json 以及 js 并通过 socket 服务器通知前端文件发生了变化 → 前端了解了有变化 → 选择是重载页面还是热更新 → 如果选择了热更新，那我们需要从后端获取 hot-update.json 文件了解是那部分的源码发生变化 → 获取该部分的更新内容 → 浏览器更换代码并销毁无用的内容")]),e._v(" "),a("li",[e._v("因此 HMR 本质上是一个通过 socket 交互的代码更换服务器")]),e._v(" "),a("li",[e._v("我们热更新的时候会发现文件并没有输出到文件夹中，这是因为我们把文件都保存到了内存中，加快了响应速度，这时候也会带来个问题，内存是珍惜资源，为了避免这个事情发生，我们要尽可能让这个文件不要过大，或者将他尽可能分块进行打包，这样能够减少性能消耗")]),e._v(" "),a("li",[e._v("有空可以看看源码 把这个实现出来")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/careteenL/webpack-hmr/",target:"_blank",rel:"noopener noreferrer"}},[e._v("careteenL/webpack-hmr"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);